let gen = false;
const frameInterval = 0.04; // 25fp, 40ms
let frame = 1;

$('.pages.stage').ready(function() {

  // when generate button is clicked
  $('#generate').on('click', function() {
    if (fixtures.length === 0) return;
    console.log(`Starting pixel generation...`);
    // clear previous lookup values
    lookup.forEach((arr) => {
      arr.length = 0;
    });
    // set video to not looping
    video.loop = false;
    $('#loop').removeClass( "on" );
    // cue video to head TODO could split out into a function in transport file
    video.pause(); // in case already playing
    video.currentTime = 0;
    // flag for generation active
    gen = true;
  });

  // notice for debugging
  $('#stage-video').on('ended', function() {
    console.log( `Video has ended` );
  });



  $('#stage-video').on('timeupdate', function() {
    if (!gen) return; // ** code below only to run if generate was clicked

    // draw new frame
    drawNewStageFrame();
    simCtx.clearRect(0, 0, vw, vh); // clear previous canvas to avoid aliasing
    drawSim();

    // update lookup table
    fixtures.forEach(function(f, i) {
      const pixel = getPixelHex( stageCtx, f.x, f.y );
      lookup[i].push( pixel );
    });

    // move to next frame
    video.currentTime += frameInterval;
    frame++;

    if (frame > numFrames) {
      console.log( 'Finished generating lookup table' );
      frame = 1; // reset frame counter
      drawFixtures(); // draw fixture icons back over
      video.currentTime = video.duration; // make sure video parks right at end in case durn wasnt evenly divis by interval
      gen = false;
    }

  });

});





//**
