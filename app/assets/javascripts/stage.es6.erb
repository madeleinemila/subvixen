let video, stage, stageCtx, sim, simCtx, vw, vh, numFrames;
// let prevTime = 0; // for generating at set intervals
const fixtures = [];
const lut = [];


// only run this js on stage page ready
$('.pages.stage').ready(function() {
  // using vanilla js from this point on to avoid vid/canvas perform issues
  // get video
  video = document.getElementById('stage-video');
  // get canvas contexts
  stage = document.getElementById('stage-canvas');
  stageCtx = stage.getContext('2d');
  sim = document.getElementById('sim-canvas');
  simCtx = sim.getContext('2d');

  // when video metadata is available
  video.addEventListener('loadedmetadata', function() {
    vw = this.videoWidth || this.width;
    vh = this.videoHeight || this.height;
    stage.width = vw;
    sim.width = vw;
    stage.height = vh;
    sim.height = vh;
    numFrames = video.duration / frameInterval;
    // show a frame to start with
    // video.play();
    // setTimeout(function() {
    //   video.pause();
    //   video.currentTime = 0;
    //   // drawNewStageFrame();  // CHANGED
    //   $('#stage-canvas').on('timeupdate', () => {
    //     drawNewStageFrame();
    //   });
    // }, 200 ); // CHANGED from 100
    video.currentTime = 0;
    setTimeout(drawNewStageFrame, 300);


    // ******* FIXTURE CREATION *********



    // fixture log helper
    const fixtureLog = function() {
        $('#fixtures-main').empty();
        for (let i = 0; i < fixtures.length; i++) {
          const f = fixtures[i];
          const node = $(`<p># <input class="f-param" value="${ f.posNum }" /> x: <input class="f-param" value="${ f.x }"/> y: <input class="f-param" value="${ f.y }"/>`);
          node.appendTo( "#fixtures-main" );
        }
    };

    // FYI, 'shape' of fixture object
    // x, y, color, posNum, i.e. position in user's hardware circuit

    stage.addEventListener('click', function(e) {
      const mousePos = getMousePos( this, e );
      fixtures.push({
        x: Math.round( mousePos.x ),
        y: Math.round( mousePos.y ),
        color: getPixelHex( stageCtx, mousePos.x, mousePos.y ),
      });
      // add a temp position number based on array position
      _(fixtures).last().posNum = fixtures.length;
      console.log( _(fixtures).last() );
      // n.b. also add empty array elem to LUT at this point
      lut.push( new Array(1) );
      drawFixtures();
      drawSim();
      fixtureLog();
    });


    // when video plays, draw to the canvases (canvi?)
    video.addEventListener('play', drawVideo, false);





  }, false); // explicit false re useCapture for older browser compat











}); // end page ready






// ******************** Component functions ***************************




// circle helper function
const drawCircle = function( x, y, r, fill, strokeWidth, strokeColor, context ) {
    context.beginPath();
    context.arc(x, y, r, 0, 2 * Math.PI, true);
    context.fillStyle = fill;
    context.fill();
    context.lineWidth = strokeWidth;
    context.strokeStyle = strokeColor;
    context.stroke();
};

const drawSim = function() {
  if (fixtures.length > 0) {
    fixtures.forEach(function(f) {
      f.color = getPixelHex( stageCtx, f.x, f.y );
      drawCircle( f.x, f.y, 10, f.color, 5, f.color, simCtx );
    });
  }
};

const drawFixtures = function() {
  if (fixtures.length > 0) {
    fixtures.forEach(function(f) {
      drawCircle( f.x, f.y, 7, '#FFF0', 3, '#222', stageCtx );
    });
  }
};

const drawNewStageFrame = function() {
  stageCtx.drawImage(video, 0, 0, vw, vh);
};

const drawVideo = function() {
  if (video.paused || video.ended) {
    gen = false; // reset gen flag if nec
    // prevTime = 0;
    return;
  }
  drawNewStageFrame(); // draws new frame of video to stage canvas
  drawFixtures(); // draw fixtures back over the top of video
  simCtx.clearRect(0, 0, vw, vh); // clear previous sim canvas to avoid aliasing
  drawSim(); // draw fixtures back into sim
  requestAnimationFrame( drawVideo );
};





// ~~~ Fixture x & y from mouse click

const getMousePos = function( canvas, event ) {
  const rect = canvas.getBoundingClientRect(); // to use clientX and clientY and normalize across browsers
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  return { x, y };
}


// ~~~ Fixture color for pixel hex

const hex = function( value ) {
  const hex = value.toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
};

const getPixelHex = function( context, x, y ) {
  const rgb = context.getImageData( x, y, 1, 1 );
  return "#" + hex( rgb.data[0] ) + hex( rgb.data[1] ) + hex( rgb.data[2] );
};
