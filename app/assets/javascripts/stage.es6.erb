let video, stage, stageCtx, sim, simCtx, vw, vh, numFrames;
let prevTime = 0; // for generating at set intervals
const fixtures = [];
const lut = [];


// only run this js on stage page ready
$('.pages.stage').ready(function() {
  // using vanilla js from this point on to avoid vid/canvas perform issues
  // get video
  video = document.getElementById('stage-video');
  // get canvas contexts
  stage = document.getElementById('stage-canvas');
  stageCtx = stage.getContext('2d');
  sim = document.getElementById('sim-canvas');
  simCtx = sim.getContext('2d');

  // when video metadata is available
  video.addEventListener('loadedmetadata', function() {
    vw = this.videoWidth || this.width;
    vh = this.videoHeight || this.height;
    stage.width = vw;
    sim.width = vw;
    stage.height = vh;
    sim.height = vh;
    numFrames = video.duration / frameInterval;
    // show first frame
    video.play();
    setTimeout(function() {
      video.pause();
      video.currentTime = 0;
    }, 100 );


    // ******* FIXTURE CREATION *********



    // fixture log helper
    const fixtureLog = function() {
        $('#fixtures-main').empty();
        for (let i = 0; i < fixtures.length; i++) {
          const f = fixtures[i];
          const node = $(`<p>${ i + 1 }. ${ f.x }, ${ f.y }</p>`);
          node.appendTo( "#fixtures-main" );
        }
    };

    stage.addEventListener('click', function(e) {
      const mousePos = getMousePos( this, e );
      fixtures.push({
        x: mousePos.x,
        y: mousePos.y,
        color: getPixelHex( stageCtx, mousePos.x, mousePos.y ),
      });
      // n.b. also add empty array elem to LUT at this point
      lut.push( new Array(1) );
      drawFixtures();
      drawSim();
      fixtureLog();
    });


    // when video plays, draw to the canvases (canvi?)
    video.addEventListener('play', drawVideo, false);





  }, false); // explicit false re useCapture for older browser compat











}); // end page ready






// ******************** Component functions ***************************




// circle helper function
const drawCircle = function( x, y, r, fill, strokeWidth, strokeColor, context ) {
    context.beginPath();
    context.arc(x, y, r, 0, 2 * Math.PI, true);
    context.fillStyle = fill;
    context.fill();
    context.lineWidth = strokeWidth;
    context.strokeStyle = strokeColor;
    context.stroke();
};

const drawSim = function() {
  if (fixtures.length > 0) {
    fixtures.forEach(function(f) {
      f.color = getPixelHex( stageCtx, f.x, f.y );
      drawCircle( f.x, f.y, 10, f.color, 5, f.color, simCtx );
    });
  }
};

const drawFixtures = function() {
  if (fixtures.length > 0) {
    fixtures.forEach(function(f) {
      drawCircle( f.x, f.y, 3, '#FFF0', 15, '#222', stageCtx );
    });
  }
};

const drawNewStageFrame = function() {
  stageCtx.drawImage(video, 0, 0, vw, vh);
};

const drawVideo = function() {
  if (video.paused || video.ended) {
    gen = false; // reset gen flag if nec
    prevTime = 0;
    console.log( lut );
    return;
  }
  if (gen) {
    // if (video.currentTime - prevTime >= 0.03315) { // 25fps with extra for computation time TODO change method so video steps through at exactly 40ms
    //   if (fixtures.length > 0) {
    //     fixtures.forEach(function(f, i) {
    //       const pixel = getPixelHex( stageCtx, f.x, f.y );
    //       lut[i].push( pixel );
    //     });
    //   }
    //
    //   prevTime = video.currentTime;
    // }
  }
  drawNewStageFrame(); // draws new frame of video to stage canvas
  drawFixtures(); // draw fixtures back over the top of video
  simCtx.clearRect(0, 0, vw, vh); // clear previous sim canvas to avoid aliasing
  drawSim(); // draw fixtures back into sim
  requestAnimationFrame( drawVideo );
};





// ~~~ Fixture x & y from mouse click

const getMousePos = function( canvas, event ) {
  // console.log(event);
  const rect = canvas.getBoundingClientRect(); // to use clientX and clientY and normalize across browsers
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  return { x, y };
}


// ~~~ Fixture color for pixel hex

const hex = function( value ) {
  const hex = value.toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
};

const getPixelHex = function( context, x, y ) {
  const rgb = context.getImageData( x, y, 1, 1 );
  return "#" + hex( rgb.data[0] ) + hex( rgb.data[1] ) + hex( rgb.data[2] );
};
